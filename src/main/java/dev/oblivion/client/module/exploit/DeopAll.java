package dev.oblivion.client.module.exploit;

import dev.oblivion.client.event.EventHandler;
import dev.oblivion.client.event.events.PacketEvent;
import dev.oblivion.client.event.events.TickEvent;
import dev.oblivion.client.module.Category;
import dev.oblivion.client.module.Module;
import dev.oblivion.client.setting.impl.BoolSetting;
import dev.oblivion.client.setting.impl.IntSetting;
import dev.oblivion.client.setting.impl.StringSetting;
import dev.oblivion.client.util.ChatUtil;
import net.minecraft.network.packet.c2s.play.RequestCommandCompletionsC2SPacket;
import net.minecraft.network.packet.s2c.play.CommandSuggestionsS2CPacket;
import net.minecraft.network.packet.s2c.play.GameMessageS2CPacket;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public final class DeopAll extends Module {
    private final StringSetting target = settings.getDefaultGroup().add(
        new StringSetting.Builder()
            .name("Target")
            .description("Player to keep opped and in their current gamemode.")
            .defaultValue("")
            .build()
    );

    private final BoolSetting setAdventure = settings.getDefaultGroup().add(
        new BoolSetting.Builder()
            .name("Adventure Mode")
            .description("Set all non-target players to adventure mode.")
            .defaultValue(true)
            .build()
    );

    private final IntSetting delayTicks = settings.getDefaultGroup().add(
        new IntSetting.Builder()
            .name("Delay")
            .description("Ticks between each command (per player).")
            .defaultValue(2)
            .range(1, 40)
            .build()
    );

    private final IntSetting refreshTicks = settings.getDefaultGroup().add(
        new IntSetting.Builder()
            .name("Refresh")
            .description("Ticks between re-querying opped players via tab completion.")
            .defaultValue(40)
            .range(10, 200)
            .build()
    );

    private final BoolSetting suppressFeedback = settings.getDefaultGroup().add(
        new BoolSetting.Builder()
            .name("Suppress Feedback")
            .description("Hide server feedback messages from deop/gamemode commands.")
            .defaultValue(true)
            .build()
    );

    private static final int COMPLETION_ID = 0x0DE0;

    private int ticks;
    private int refreshCounter;
    private int playerIndex;
    private String resolvedTarget;
    private final List<String> oppedPlayers = new ArrayList<>();
    private final Set<String> confirmedNotOpped = new HashSet<>();

    public DeopAll() {
        super("DeopAll", "Deops everyone except the target using tab-completion to detect opped players.", Category.EXPLOIT);
    }

    @Override
    protected void onEnable() {
        ticks = 0;
        refreshCounter = 0;
        playerIndex = 0;
        oppedPlayers.clear();
        confirmedNotOpped.clear();
        resolvedTarget = target.get().trim();
        if (resolvedTarget.isEmpty() && mc.player != null) {
            resolvedTarget = mc.player.getName().getString();
            ChatUtil.info("No target set, defaulting to you: " + resolvedTarget);
        }
        ChatUtil.success("DeopAll enabled. Protecting: " + resolvedTarget);
        requestOppedPlayers();
    }

    @Override
    protected void onDisable() {
        oppedPlayers.clear();
        confirmedNotOpped.clear();
    }

    private void requestOppedPlayers() {
        if (mc.player == null || mc.getNetworkHandler() == null) return;
        mc.player.networkHandler.sendPacket(new RequestCommandCompletionsC2SPacket(COMPLETION_ID, "/deop "));
    }

    @EventHandler
    public void onPacketReceive(PacketEvent.Receive event) {
        if (event.getPacket() instanceof CommandSuggestionsS2CPacket packet) {
            if (packet.id() != COMPLETION_ID) return;

            oppedPlayers.clear();
            confirmedNotOpped.clear();
            playerIndex = 0;
            for (var suggestion : packet.getSuggestions().getList()) {
                String name = suggestion.getText();
                if (!name.equalsIgnoreCase(resolvedTarget)) {
                    oppedPlayers.add(name);
                }
            }
            return;
        }

        if (suppressFeedback.get() && event.getPacket() instanceof GameMessageS2CPacket packet) {
            String msg = packet.content().getString();
            if (msg.contains("Nothing changed") || msg.contains("is not an operator")
                    || msg.contains("Made") && msg.contains("no longer an operator")
                    || msg.contains("Set") && msg.contains("game mode to")) {
                event.cancel();
            }
        }
    }

    @EventHandler
    public void onTick(TickEvent.Post event) {
        if (mc.player == null || mc.getNetworkHandler() == null) return;

        refreshCounter++;
        if (refreshCounter >= refreshTicks.get()) {
            refreshCounter = 0;
            confirmedNotOpped.clear();
            requestOppedPlayers();
        }

        if (oppedPlayers.isEmpty()) return;

        ticks++;
        if (ticks < delayTicks.get()) return;
        ticks = 0;

        // Find next player who isn't confirmed as not-opped
        int checked = 0;
        while (checked < oppedPlayers.size()) {
            if (playerIndex >= oppedPlayers.size()) playerIndex = 0;
            String name = oppedPlayers.get(playerIndex);
            playerIndex++;
            checked++;

            if (confirmedNotOpped.contains(name.toLowerCase())) continue;

            mc.getNetworkHandler().sendChatCommand("deop " + name);
            if (setAdventure.get()) {
                mc.getNetworkHandler().sendChatCommand("gamemode adventure " + name);
            }
            return;
        }
    }
}
